# File: Plotting Functions
# Author: Jake Gaecke
# Description: This file contains custom functions that have been written to simplify common plotting tasks.

#### General Purpose Plotting Functions ####
#' Humana Colors
#'
#' Returns Humana colors in HEX values for use in plots. Use n to expand this color list with ligher and darker versions of each color.
#' @param n The number of colors to be output. If n is even, this function will output an additional color in order to include the original as the center color.
#' @keywords humana, colors, humcols, expand_colors
#' @export
#' @examples
#' getHumanaColors()
getHumanaColors <- function(n = 1){
  # returns a vector of Humana colors
  #             green,     plum,      grey,      dark green
  hum_cols <- c("#5C9A1B", "#AA005F", "#D5D5D5", "#1D5B2D") #humana colors
  hum_cols <- expand_colors(hum_cols, n)

  return(hum_cols)
}

#' Expand Colors
#'
#' Takes a vector of colors and returns a vector of (at least) n colors per original color that are equally lighter and darker than the original.
#' This function will always output at least the original colors.
#' @param col A vector of colors.
#' @param n The number of colors to be output. If n is even, this function will output an additional color in order to include the original as the center color.
#' @keywords colors, shades, lighter, darker
#' @export
#' @examples
#' expand_colors(getHumanaColors(), 2) # This will add a single lighter and darker version of each color in the original vector
expand_colors <- function(col, n) {

  cols <- c()
  n_half <- ceiling((n-1)/2)
  n <- 1 + n_half * 2
  col_offset <- c(1/n, 1/n, 1/n, 0)


  #generate lightest colors first
  if(n_half > 0){
    for( i in n_half:1) {
      col_adj <- adjustcolor(col, offset = col_offset * i * 1)
      cols <- na.omit(rbind(cols, col_adj, deparse.level = 0))
    }
  }
  # original color
  cols <- na.omit(rbind(cols, col, deparse.level = 0))
  # generate darker colors last
  if(n_half > 0){
    for(i in 1:n_half) {
      col_adj <- adjustcolor(col, offset = col_offset * i * -1)
      cols <- na.omit(rbind(cols, col_adj, deparse.level = 0))
    }
  }
  return(as.vector(cols))
}


#### ggplot2 ####

#' Title with Subtitle
#'
#' This function modifies the title and adds in a subtitle to a plot generated by ggplot2.
#' @param title Title of plot.
#' @param subtitle Subtitle of plot
#' @keywords ggplot2, title, subtitle
#' @export
#' @examples
#' ggplot(dat, aes(x = x, y = y)) + goem_point() +
#' title_with_subtitle(title = "The Title of the Plot", subtitle = "The Subtitle that explains more detail of the Title")
title_with_subtitle = function(title, subtitle = "") {
  ggtitle(bquote(atop(.(title), atop(.(subtitle)))))
}

#' Legend Title
#'
#' This function modifies the title of a legend without having to specify a new color palette.
#' This is mainly a convenience function.
#' @param title Title of legend.
#' @keywords ggplot2, legend, guide
#' @export
#' @examples
#' ggplot(dat, aes(x = x, y = y)) + goem_point() +
#' legend_title(title = "Legend Title")
legend_title <- function(title) {
  guides(fill=guide_legend(title=title))
}

#' Theme - Jake Gaecke
#'
#' This function specifies a theme created by Jake Gaecke for plotting in ggplot2.
#' It is based on theme_bw() with light grey background, dashed minor grid lines, and legend defaulting to the bottom.
#' @param base_size Determines the base size of the text in theme elements.
#' @keywords ggplot2, theme, theme_bw
#' @export
#' @examples
#' ggplot(dat, aes(x = x, y = y)) + goem_point() +
#' theme_jg(base_size = 18)
theme_jg = function(base_size = 12, bg_color = "white") {
  # consider using bg_color = "#f4f4f4"
  bg_rect = element_rect(fill = bg_color, color = bg_color)

  theme_bw(base_size) +
    theme(plot.background = bg_rect,
          panel.background = bg_rect,
          legend.background = bg_rect,
          legend.key = element_blank(), #removes box around legend elements
          legend.position = "bottom",
          panel.grid.major = element_line(colour = "#c4c4c4", size = 0.25), #grey80
          panel.grid.minor = element_line(colour = "#dcdcdc", size = 0.25, linetype = "dashed") #grey90
    )
}


#' FIPS Choropleth
#'
#' This function takes a data frame with State, County Code and a single metric, and returns a ggplot choropleth of the United States.
#' @param base_size Determines the base size of the text in theme elements.
#' @keywords ggplot2, choropleth, map,
#' @export
#' @examples
#' fips_choropleth(dat_map, "metric")
fips_choropleth <- function(dat, str_metric, cols = getHumanaColors(5)) {
  require(ggplot2)
  require(readr)
  require(dplyr)
  require(magrittr)

  #dat must have state, cnty_cd, and a metric that matches str_metric
  # state is the state abbreviation in all caps
  # cnty_cd is the county code as a number (no leading zeros)
  # str_metric is the name of the column to be used for assigning color to the choropleth
  ## works best with discrete variables

  # Import crosswalk table
  dat_crosswalk <- read_csv("R:/EmployerGroup/SharedCode/Prod/UtilityPrograms/mapping_crosswalk.csv")

  # Join together
  dat_map <- left_join(
    dat,
    dat_crosswalk,
    by = c("state" = "state", "cnty_cd" = "cnty_cd")
  )

  # Import data used for defining map
  dat_cnty <- map_data("county")
  dat_cnty %<>% mutate(county_name = paste(region, subregion, sep = ","))

  dat_map %<>% left_join(dat_cnty, .,
                       by = c("county_name" = "polyname")) %>%
              arrange(order)
  dat_state <- map_data("state")

  return(
    ggplot(dat_map, aes(long, lat, group = group)) +
      geom_polygon(fill = "darkgrey", alpha = 0.75) +
      geom_polygon(aes_string(fill = str_metric)) +
      scale_fill_manual(values = cols) +
      coord_map(project = "globular", xlim = c(-120.7, -72.4), ylim = c(25.4, 49.3)) +
      theme(axis.title = element_blank(),
            axis.text = element_blank(),
            axis.ticks = element_blank(),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.background = element_blank(),
            legend.position = "bottom"
            ) +
      geom_path(data = dat_state, colour = "#f4f4f4", size = .7) +
      geom_path(data = dat_cnty, colour = "#f4f4f4", size = .5, alpha = .1)
  )

}


#### Word Plots ####

#' Wordcloud Data
#'
#' This function prepares a single column of word data to be used in a wordcloud plot
#' This is mainly a convenience function.
#' @param dat_text A single column of data containing words to be made into a wordcloud
#' @keywords wordcloud, corpus,
#' @export
#' @examples
#' dat_terms <- wordcloud_data(dat_sparc$Narrative)
#' # This is how you export a plot
#'  png("wordcloud.png", width=1280, height=1280, units="px", res=320, type = "cairo-png", antialias = "subpixel")
#'    # note that a wordcloud's word placement is random. You might want to run this a few times until you get one you like.
#'    wordcloud(names(dat_terms), terms, scale=c(4, 0.5),
#'              min.freq = 25, max.words=200, # these control which words make it into the plot
#'              colors=getHumanaColors()) # Use Humana colors
#'  dev.off() # Stop waiting for plots to export
wordcloud_data <- function(dat_text){
  # dat_text must be a single column of data containing words to be made into a world cloud

  source("R:/EmployerGroup/SharedCode/Prod/UtilityPrograms/general_functions.R") # This includes Humana colors
  library(magrittr) # This includes the %>% operator

  # Load packages to create a wordcloud
  require(tm)
  require(wordcloud)
  require(RColorBrewer)

  # Corpus ~ a collection of written texts, especially the entire works of a particular author or a body of writing on a particular subject.
  dat_corpus <- dat_text %>%
    as.data.frame() %>%
    DataframeSource() %>%
    Corpus()

  dat_corpus <- tm_map(dat_corpus, content_transformer(tolower)) # removes differences in capitalization
  dat_corpus <- tm_map(dat_corpus, removePunctuation) # no one cares about your punctuation
  dat_corpus <- tm_map(dat_corpus, removeNumbers) # no one cares about the numbers
  dat_corpus <- tm_map(dat_corpus, removeWords, stopwords("english")) # remove uninteresting words

  dat_tdm <- TermDocumentMatrix(dat_corpus, control = list(minWordLength = 1))
  dat_tdm <- as.matrix(dat_tdm)

  dat_terms <- sort(rowSums(dat_tdm), decreasing = TRUE) # sort words by their frequency
  return(dat_terms)

  # Example usage of data #
  # This is how you export a plot
  #png("wordcloud.png", width=1280, height=1280, units="px", res=320, type = "cairo-png", antialias = "subpixel")
  # note that a wordcloud's word placement is random. You might want to run this a few times until you get one you like.
  #wordcloud(names(dat_terms), terms, scale=c(4, 0.5),
  #          min.freq = 25, max.words=200, # these control which words make it into the plot
  #          colors=getHumanaColors()) # Use Humana colors
  #dev.off() # Stop waiting for plots to export
}
